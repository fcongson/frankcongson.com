---
title: Prismic Headless CMS vs Forestry Git Backed CMS
description: Where should I keep my content? It depends.
date: 2020-07-20
slug: headless-vs-git-backed-cms
featured_image: '../../images/forestry-dev-illustration.jpg'
alt_text: Forestry.io dev illustration
keywords:
  - headless cms
  - cms
  - git backed cms
  - git
  - mdx
  - markdown
  - forestry.io
  - prismic.io
  - sanity.io
seo:
  image: '../../images/forestry-dev-illustration.jpg'
  alt_text: Forestry.io dev illustration
published: true
---

<section>

When I began thinking about how I would rebuild my website, I always thought I would use a [Headless CMS](https://headlesscms.org/about). The idea of having a dedicated place to create and manage content was familiar since I was coming from [WordPress](https://wordpress.org/). As I was transitioning to the idea of building with the [Jamstack](https://jamstack.org/), a Headless CMS seemed to fit the API portion of the JAM. So began my journey of finding the right Headless CMS. The two that I landed on were [Sanity](https://www.sanity.io/) and [Prismic](https://prismic.io/). Both provided enough from their free tier, both provided GraphQL endpoints, and both recommended by [Wes Bos](https://twitter.com/wesbos) and [Scott Tolinski](https://twitter.com/stolinski) in their [Syntax Podcast](https://syntax.fm/) (such a great podcast by the way 👍).

## Going Headless

I was able to get data flowing into my [Gatsby](https://www.gatsbyjs.com/) blog pretty quickly. Both Sanity and Prismic have great documentation, examples, and tutorials. I love that Sanity allows you to [hot-spot](https://www.sanity.io/docs/presenting-images#the-crop-and-hot-spot-QsZtvbLC) a photo to ensure that area is visible when handling responsive layouts. Creating custom types in Prismic is simple, with the use of their [slices](https://user-guides.prismic.io/en/articles/383933-slices).

Ultimately, I decided to go with Prismic for my Headless CMS. Prismic was slightly easier to maintain because I didn't have the extra overhead of [Sanity Studio](https://www.sanity.io/studio), the UI to the Sanity Headless CMS. Sanity Studio provided customization for the editing experience, but it wasn't something that I needed at the time. I was more focused on creating custom React components to use on my website, which aligned perfectly with Prismic's slices.

## Trying Out Markdown

My initial experience with learning to create a Gatsby blog was with creating content in [Markdown](https://www.gatsbyjs.com/guides/markdown/). The idea of Markdown is that the content lives with the code, removing the need for a CMS. The benefit of this is that there is one less external dependency. I didn't need packages to query my content from the Headless CMS. Removing that dependency became a strong driver towards moving away from a Headless CMS and keeping my content with my code. As new versions of Gatsby and Prismic were released, it became a challenge to keep everything working with the latest versions. Removing the dependency on Prismic allowed me to update Gatsby without losing the ability to query my content.

## Best Of Both Worlds

I missed the editing experience of having a dedicated place like Forestry to edit my content. But I loved that my content was close by right next to my code. Thus began my search for a beautifully designed markdown editor. During my search, I stumbled upon [Forestry](https://forestry.io/).

> The main thing to understand is that Forestry – unlike other content management systems – is entirely backed by Git. To put it simply, Forestry is an editor-friendly interface over Git. This means that developers and editors can now use the same workflow and tool set. This also means that all of your content and code always belongs to you, and is not stored in a database in the cloud out of your reach.

Forestry provides a beautiful editing experience, similar to a Headless CMS, and it creates content in Markdown, committing the changes directly into my [GitHub](https://github.com/fcongson) repository. As a bonus, there are no additional dependencies to using Forestry. My code continued to read the content from Markdown. Forestry provides an elegant workflow that fits my needs.

</section>
